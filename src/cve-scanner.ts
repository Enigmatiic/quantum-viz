// =============================================================================
// CVE SCANNER - Détection de vulnérabilités dans les dépendances
// Supporte npm (package.json), Cargo (Cargo.toml), pip (requirements.txt)
// =============================================================================

import * as fs from 'fs';
import * as path from 'path';

// =============================================================================
// TYPES
// =============================================================================

export type DependencyEcosystem = 'npm' | 'cargo' | 'pip' | 'go';

export interface Dependency {
  name: string;
  version: string;
  isDev: boolean;
  ecosystem: DependencyEcosystem;
}

export interface DependencyFile {
  type: DependencyEcosystem;
  path: string;
  dependencies: Dependency[];
}

export interface VulnerabilityInfo {
  id: string;              // CVE-2024-XXXXX or GHSA-xxxx
  aliases: string[];       // Other identifiers
  severity: 'critical' | 'high' | 'medium' | 'low' | 'unknown';
  cvss?: number;
  summary: string;
  details?: string;
  affected: string[];      // Affected version ranges
  fixed?: string[];        // Fixed versions
  references: string[];
  published?: string;
  modified?: string;
}

export interface DependencyVulnerability {
  dependency: Dependency;
  vulnerabilities: VulnerabilityInfo[];
}

export interface CVEScanResult {
  scannedAt: Date;
  ecosystem: DependencyEcosystem;
  totalDependencies: number;
  vulnerableDependencies: number;
  vulnerabilities: DependencyVulnerability[];
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    unknown: number;
  };
}

// =============================================================================
// OSV CLIENT
// =============================================================================

interface OSVQueryResponse {
  vulns?: OSVVulnerability[];
}

interface OSVVulnerability {
  id: string;
  aliases?: string[];
  summary?: string;
  details?: string;
  severity?: { type: string; score: string }[];
  affected?: {
    package?: { ecosystem: string; name: string };
    ranges?: { type: string; events: { introduced?: string; fixed?: string }[] }[];
    versions?: string[];
  }[];
  references?: { type: string; url: string }[];
  published?: string;
  modified?: string;
}

export class OSVClient {
  private baseUrl = 'https://api.osv.dev/v1';
  private cache: Map<string, { data: VulnerabilityInfo[]; timestamp: number }> = new Map();
  private cacheTTL = 24 * 60 * 60 * 1000; // 24 hours

  async queryVulnerabilities(
    packageName: string,
    version: string,
    ecosystem: string
  ): Promise<VulnerabilityInfo[]> {
    const cacheKey = `${ecosystem}:${packageName}@${version}`;

    // Check cache
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return cached.data;
    }

    try {
      const response = await fetch(`${this.baseUrl}/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          package: {
            name: packageName,
            ecosystem: this.mapEcosystem(ecosystem)
          },
          version: version
        })
      });

      if (!response.ok) {
        console.warn(`OSV API error for ${packageName}@${version}: ${response.status}`);
        return [];
      }

      const data: OSVQueryResponse = await response.json();
      const vulns = this.parseOSVResponse(data);

      // Cache result
      this.cache.set(cacheKey, { data: vulns, timestamp: Date.now() });

      return vulns;
    } catch (error) {
      console.warn(`Failed to query OSV for ${packageName}@${version}:`, error);
      return [];
    }
  }

  private mapEcosystem(ecosystem: string): string {
    const mapping: Record<string, string> = {
      'npm': 'npm',
      'cargo': 'crates.io',
      'pip': 'PyPI',
      'go': 'Go'
    };
    return mapping[ecosystem] || ecosystem;
  }

  private parseOSVResponse(data: OSVQueryResponse): VulnerabilityInfo[] {
    if (!data.vulns) return [];

    return data.vulns.map(vuln => ({
      id: vuln.id,
      aliases: vuln.aliases || [],
      severity: this.parseSeverity(vuln.severity),
      cvss: this.parseCVSS(vuln.severity),
      summary: vuln.summary || 'No description available',
      details: vuln.details,
      affected: this.parseAffectedVersions(vuln.affected),
      fixed: this.parseFixedVersions(vuln.affected),
      references: (vuln.references || []).map(r => r.url),
      published: vuln.published,
      modified: vuln.modified
    }));
  }

  private parseSeverity(
    severity?: { type: string; score: string }[]
  ): VulnerabilityInfo['severity'] {
    if (!severity || severity.length === 0) return 'unknown';

    const cvssEntry = severity.find(s => s.type === 'CVSS_V3' || s.type === 'CVSS_V2');
    if (!cvssEntry) return 'unknown';

    const score = parseFloat(cvssEntry.score);
    if (isNaN(score)) return 'unknown';

    if (score >= 9.0) return 'critical';
    if (score >= 7.0) return 'high';
    if (score >= 4.0) return 'medium';
    return 'low';
  }

  private parseCVSS(severity?: { type: string; score: string }[]): number | undefined {
    if (!severity) return undefined;
    const cvssEntry = severity.find(s => s.type === 'CVSS_V3' || s.type === 'CVSS_V2');
    if (!cvssEntry) return undefined;
    const score = parseFloat(cvssEntry.score);
    return isNaN(score) ? undefined : score;
  }

  private parseAffectedVersions(affected?: OSVVulnerability['affected']): string[] {
    if (!affected) return [];

    const versions: string[] = [];
    affected.forEach(a => {
      if (a.versions) {
        versions.push(...a.versions);
      }
      if (a.ranges) {
        a.ranges.forEach(r => {
          r.events.forEach(e => {
            if (e.introduced) versions.push(`>=${e.introduced}`);
          });
        });
      }
    });
    return versions;
  }

  private parseFixedVersions(affected?: OSVVulnerability['affected']): string[] {
    if (!affected) return [];

    const fixed: string[] = [];
    affected.forEach(a => {
      if (a.ranges) {
        a.ranges.forEach(r => {
          r.events.forEach(e => {
            if (e.fixed) fixed.push(e.fixed);
          });
        });
      }
    });
    return [...new Set(fixed)];
  }
}

// =============================================================================
// DEPENDENCY PARSERS
// =============================================================================

export function parsePackageJson(filePath: string): Dependency[] {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const pkg = JSON.parse(content);
    const deps: Dependency[] = [];

    // Regular dependencies
    if (pkg.dependencies) {
      Object.entries(pkg.dependencies).forEach(([name, version]) => {
        deps.push({
          name,
          version: cleanVersion(version as string),
          isDev: false,
          ecosystem: 'npm'
        });
      });
    }

    // Dev dependencies
    if (pkg.devDependencies) {
      Object.entries(pkg.devDependencies).forEach(([name, version]) => {
        deps.push({
          name,
          version: cleanVersion(version as string),
          isDev: true,
          ecosystem: 'npm'
        });
      });
    }

    return deps;
  } catch (error) {
    console.warn(`Failed to parse package.json at ${filePath}:`, error);
    return [];
  }
}

export function parseCargoToml(filePath: string): Dependency[] {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const deps: Dependency[] = [];

    // Simple regex parsing for Cargo.toml
    // Match [dependencies] section
    const depSectionRegex = /\[dependencies\]([\s\S]*?)(?=\[|$)/;
    const devDepSectionRegex = /\[dev-dependencies\]([\s\S]*?)(?=\[|$)/;

    const parseSection = (section: string, isDev: boolean) => {
      const lines = section.split('\n');
      lines.forEach(line => {
        // Match: package_name = "version" or package_name = { version = "x" }
        const simpleMatch = line.match(/^(\w[\w-]*)\s*=\s*"([^"]+)"/);
        const tableMatch = line.match(/^(\w[\w-]*)\s*=\s*\{[^}]*version\s*=\s*"([^"]+)"/);

        const match = simpleMatch || tableMatch;
        if (match) {
          deps.push({
            name: match[1],
            version: cleanVersion(match[2]),
            isDev,
            ecosystem: 'cargo'
          });
        }
      });
    };

    const depMatch = content.match(depSectionRegex);
    if (depMatch) parseSection(depMatch[1], false);

    const devDepMatch = content.match(devDepSectionRegex);
    if (devDepMatch) parseSection(devDepMatch[1], true);

    return deps;
  } catch (error) {
    console.warn(`Failed to parse Cargo.toml at ${filePath}:`, error);
    return [];
  }
}

export function parseRequirementsTxt(filePath: string): Dependency[] {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const deps: Dependency[] = [];

    const lines = content.split('\n');
    lines.forEach(line => {
      // Skip comments and empty lines
      line = line.trim();
      if (!line || line.startsWith('#')) return;

      // Match: package==version, package>=version, package~=version
      const match = line.match(/^([\w-]+)([=<>~!]+)?(.+)?$/);
      if (match) {
        deps.push({
          name: match[1],
          version: match[3] ? cleanVersion(match[3]) : '*',
          isDev: false,
          ecosystem: 'pip'
        });
      }
    });

    return deps;
  } catch (error) {
    console.warn(`Failed to parse requirements.txt at ${filePath}:`, error);
    return [];
  }
}

function cleanVersion(version: string): string {
  // Remove common prefixes: ^, ~, >=, <=, =, etc.
  return version.replace(/^[\^~>=<]+/, '').trim();
}

// =============================================================================
// CVE SCANNER
// =============================================================================

export class CVEScanner {
  private osvClient: OSVClient;

  constructor() {
    this.osvClient = new OSVClient();
  }

  async scanDirectory(dir: string): Promise<CVEScanResult[]> {
    const results: CVEScanResult[] = [];

    // Find dependency files
    const depFiles = this.findDependencyFiles(dir);

    for (const depFile of depFiles) {
      const result = await this.scanDependencyFile(depFile);
      results.push(result);
    }

    return results;
  }

  private findDependencyFiles(dir: string): DependencyFile[] {
    const files: DependencyFile[] = [];

    // package.json
    const packageJsonPath = path.join(dir, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      files.push({
        type: 'npm',
        path: packageJsonPath,
        dependencies: parsePackageJson(packageJsonPath)
      });
    }

    // Cargo.toml
    const cargoTomlPath = path.join(dir, 'Cargo.toml');
    if (fs.existsSync(cargoTomlPath)) {
      files.push({
        type: 'cargo',
        path: cargoTomlPath,
        dependencies: parseCargoToml(cargoTomlPath)
      });
    }

    // requirements.txt
    const requirementsPath = path.join(dir, 'requirements.txt');
    if (fs.existsSync(requirementsPath)) {
      files.push({
        type: 'pip',
        path: requirementsPath,
        dependencies: parseRequirementsTxt(requirementsPath)
      });
    }

    return files;
  }

  async scanDependencyFile(depFile: DependencyFile): Promise<CVEScanResult> {
    const vulnerabilities: DependencyVulnerability[] = [];
    const summary = { critical: 0, high: 0, medium: 0, low: 0, unknown: 0 };

    console.log(`  Scanning ${depFile.dependencies.length} ${depFile.type} dependencies...`);

    // Query OSV for each dependency (with rate limiting)
    for (const dep of depFile.dependencies) {
      if (dep.version === '*' || dep.version === 'latest') continue;

      const vulns = await this.osvClient.queryVulnerabilities(
        dep.name,
        dep.version,
        dep.ecosystem
      );

      if (vulns.length > 0) {
        vulnerabilities.push({ dependency: dep, vulnerabilities: vulns });

        // Count by severity
        vulns.forEach(v => {
          summary[v.severity]++;
        });
      }

      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    return {
      scannedAt: new Date(),
      ecosystem: depFile.type,
      totalDependencies: depFile.dependencies.length,
      vulnerableDependencies: vulnerabilities.length,
      vulnerabilities,
      summary
    };
  }

  formatReport(results: CVEScanResult[]): string {
    const lines: string[] = [];

    results.forEach(result => {
      lines.push(`\n=== ${result.ecosystem.toUpperCase()} Dependencies ===`);
      lines.push(`Scanned: ${result.totalDependencies} packages`);
      lines.push(`Vulnerable: ${result.vulnerableDependencies} packages`);

      if (result.summary.critical > 0) {
        lines.push(`  CRITICAL: ${result.summary.critical}`);
      }
      if (result.summary.high > 0) {
        lines.push(`  HIGH: ${result.summary.high}`);
      }
      if (result.summary.medium > 0) {
        lines.push(`  MEDIUM: ${result.summary.medium}`);
      }
      if (result.summary.low > 0) {
        lines.push(`  LOW: ${result.summary.low}`);
      }

      result.vulnerabilities.forEach(dv => {
        lines.push(`\n  ${dv.dependency.name}@${dv.dependency.version}:`);
        dv.vulnerabilities.forEach(v => {
          const cvss = v.cvss ? ` (CVSS: ${v.cvss})` : '';
          lines.push(`    - [${v.severity.toUpperCase()}] ${v.id}${cvss}`);
          lines.push(`      ${v.summary}`);
          if (v.fixed && v.fixed.length > 0) {
            lines.push(`      Fixed in: ${v.fixed.join(', ')}`);
          }
        });
      });
    });

    return lines.join('\n');
  }
}
